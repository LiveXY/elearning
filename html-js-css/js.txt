h5page:
http://m.ac.qq.com/

http://p.m.jd.com/norder/freeRegister.action?sid=75b66bb1d5e92cd94d52d10ae81d242a&flowType=&wareId=11995765&wareNum=1#chooseAddressPage
http://p.m.jd.com/norder/selectProvince.action
http://p.m.jd.com/norder/selectCity.action?idProvince=7
http://p.m.jd.com/norder/selectArea.action?idCity=549
http://p.m.jd.com/norder/selectTown.action?idArea=557

lazyload
http://vm.gtimg.cn/tencentvideo_v1/script/film/weixin/v2/common/lazyload.js
http://dev.film.qq.com/tencentvideo_v1/script/film/weixin/v2/common/lazyload.js
http://jiehe0205.github.io/2016/08/06/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/

http://qzs.qq.com/tencentwap/js/txmv.base.banner.min.js?v=20150721
http://pingjs.qq.com/ping_video.js?max_age=31104000

开调试
(function() {} ['constructor']('debugger')())

js获取联网类型
var connection = navigator.connection||navigator.mozConnection||navigator.webkitConnection||{tyep:'unknown'};
var type_text = ['unknown','ethernet','wifi','2g','3g','4g','none'];

alert(connection.type);
var re_el = document.getElementById("re");
var btn_el = document.getElementById("btn");
function get_status(){
	if(typeof(connection.type) == "number"){
		connection.type_text = type_text[connection.type];
	}else{
		connection.type_text = connection.type;
	}
	if(typeof(connection.bandwidth) == "number"){
		if(connection.bandwidth > 10){
			connection.type = 'wifi';
		}else if(connection.bandwidth > 2){
			connection.type = '3g';
		}else if(connection.bandwidth > 0){
			connection.type = '2g';
		}else if(connection.bandwidth == 0){
			connection.type = 'none';
		}else{
			connection.type = 'unknown';
		}
	}
	var html = 'Type : '+connection.type_text;
		html += '<br>Bandwidth : '+connection.bandwidth;
		html += '<br>isOnline : '+navigator.onLine;
		re_el.innerHTML = html;
}

btn_el.onclick = function(){
	re_el.innerHTML = 'Waiting...';
	get_status();
}

==========================================================
function serialnum() { this.$n = 0;}
serialnum.prototype.__defineSetter__("next", function(n){
	this.$n = n;
});
serialnum.prototype.__defineGetter__("next", function(){
	return this.$n;
});
function serialnum() {
	var $n = 0;
	this.__defineSetter__("next", function(n){
		$n = n;
	});
	this.__defineGetter__("next", function(){
		return $n;
	});
}
==========================================================
(function() {
    //页面降域名
    try {
        document.domain = 'qq.com';
    } catch (ex) {}

    function insertScript(id, url, callback) {
        if (document.getElementById(id) || !url) {
            callback && callback();
            return;
        }
        var node = document.createElement('script'),
            script = document.getElementsByTagName('script')[0];
        node.src = url;
        node.type = 'text/javascript';
        node.charset = "UTF-8";
        node.onload = node.onerror = node.onreadystatechange = function() {
            /loaded|complete|undefined/.test(node.readyState) && function() {
                node.onload = node.onerror = node.onreadystatechange = null;
                node.parentNode.removeChild(node);
                node = undefined;
                callback && callback();
            }();
        };
        script.parentNode.insertBefore(node, script);
    }
    // 调用一把pgvMain()才会把pgv_pvid种到cookie里
    insertScript('js_tcss', '//pingjs.qq.com/ping_video.js?max_age=31104000', function() {
        window.pgvMain && window.pgvMain();
    });
    // 页面的pv、uv boss上报
    insertScript('js_hlwstats', '//vm.gtimg.cn/tencentvideo_v1/script/film/open/hlwstats.js?v=20170306&max_age=31104000', function() {
        window.HLWSTATE && window.HLWSTATE.pgvMain();
    });
})();

=======================================================
(function (doc, win) {
	var docEl = doc.documentElement,
		docBody = doc.body,
		resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
		recalc = function () {
			var clientWidth = docEl.clientWidth;
			if (!clientWidth) return;

			clientWidth = Math.min(Math.max(clientWidth, 320), 640);
			docEl.style.fontSize = 100 * (clientWidth / 320) + 'px';
		};
	if (!doc.addEventListener) return;
	docEl && recalc();
	doc.addEventListener('DOMContentLoaded', recalc, false);
	win.addEventListener(resizeEvt, recalc, false);
})(document, window);
===========================================================
AutoPage();
var  timer=setInterval(AutoPage,30);
function AutoPage(){
    document.documentElement.style.fontSize = document.documentElement.clientWidth * 100 / 640 + 'px';
 } ;
window.addEventListener("onorientationchange" in window ? "orientationchange" : "resize" , AutoPage, false);
==========================================================
$(function() {
    if($(".meipian-content").length == 0) {
        var content = $(".mp-content");
    }else{
        var content = $(".meipian-content");
    }
    var img = content.find("img").last();
    img.load(function() {
        var scrollHeight = $(window).scrollTop();
        function getHeight(){
            if($(".section").length == 0){
                var section = $(".mp-section");
            }else{
                var section = $(".section");
            }
            var screenHeight = $(window).height() * 3;//超过文章内容超过4倍高度执行文章折叠
            var contentHeight = content.height();
            var notFoldHeight = null;
            var foldHeight = null;
            var otherTop = $(section[0]).offset().top;
            for(var i = 0, len = section.length; i < len; i++) {
                if($(section[i]).offset().top - otherTop >= screenHeight) {
                    notFoldHeight = $(section[i]).offset().top - otherTop;
                    foldHeight = contentHeight - notFoldHeight;
                    if(foldHeight > $(window).height() * 2) {
                        return notFoldHeight;
                    }else{
                        return null;
                    }
                }
            }
            return null;
        }
        if(getHeight() && $(window).height() * 5 < content.height()) {
            if(scrollHeight + $(window).height() < $(window).height() * 3) {
                content.css({
                    "height":getHeight(),
                    "overflow":"hidden"
                });
                content.after('<div id="loadMore"><p><a href="javascript:void(0);"><span>展开阅读全文</span><span class="iconfont icon-arrow"></span></a></p></div>');
                $("#loadMore").click(function() {
                    $(this).remove();
                    content.css({"height":"auto"});
                });
            }
        }
    });
});
======================================
预览图片
if (window.android)
{
    window.android.previewImage(i, imgList);
}

try
{
    wx.previewImage(message);
}
catch (err) {}
window.webkit.messageHandlers.previewImage.postMessage(message);


如何优雅地链式取值
res.data.goods.list[0].price
var object = { a: [{ b: { c: 3 } }] };
var result = _.get(object, 'a[0].b.c', 1);
console.log(result);
function get (obj, props, def) {
    if((obj == null) || obj == null || typeof props !== 'string') return def;
    const temp = props.split('.');
    const fieldArr = [].concat(temp);
    temp.forEach((e, i) => {
        if(/^(\w+)\[(\w+)\]$/.test(e)) {
            const matchs = e.match(/^(\w+)\[(\w+)\]$/);
            const field1 = matchs[1];
            const field2 = matchs[2];
            const index = fieldArr.indexOf(e);
            fieldArr.splice(index, 1, field1, field2);
        }
    })
    return fieldArr.reduce((pre, cur) => {
        const target = pre[cur] || def;

        if(target instanceof Array) {
            return [].concat(target);
        }
        if(target instanceof Object) {
            return Object.assign({}, target)
        }
        return target;
    }, obj)
}
var c = {a: {b : [1,2,3] }}
get(c ,'a.b')     // [1,2,3]
get(c, 'a.b[1]')  // 2
get(c, 'a.d', 12)  // 12

使用Proxy
function pointer(obj, path = []) {
    return new Proxy({}, {
        get (target, property) {
            return pointer(obj, path.concat(property))
        },
        apply (target, self, args) {
            let val = obj;
            let parent;
            for(let i = 0; i < path.length; i++) {
                if(val === null || val === undefined) break;
                parent = val;
                val = val[path[i]]
            }
            if(val === null || val === undefined) {
                val = args[0]
            }
            return val;
        }
    })
}
let c = {a: {b: [1, ,2 ,3]}}
pointer(c).a();   // {b: [1,2,3]}
pointer(c).a.b(); // [1,2,3]
pointer(d).a.b.d('default value');

ios中，输入框获得焦点时，页面输入框被遮盖，定位的元素位置错乱：
inputOnFocus(e){
    setTimeout(function(){
        e.target.scrollIntoView(true);

    },200);
}

移动Web开发，4行代码检测浏览器是否支持position:fixed
function isSupportFixed() {
    var userAgent = window.navigator.userAgent,
        ios = userAgent.match(/(iPad|iPhone|iPod)\s+OS\s([\d_\.]+)/),
        ios5below = ios && ios[2] && (parseInt(ios[2].replace(/_/g, '.'), 10) < 5),
        operaMini = /Opera Mini/i.test(userAgent),
        body = document.body,
        div, isFixed;

    div = document.createElement('div');
    div.style.cssText = 'display:none;position:fixed;z-index:100;';
    body.appendChild(div);
    isFixed = window.getComputedStyle(div).position != 'fixed';
    body.removeChild(div);
    div = null;

    return !!(isFixed || ios5below || operaMini);
}

判断屏幕是否旋转

function orientationChange() {
    switch(window.orientation) {
    　　case 0:
            alert("肖像模式 0,screen-width: " + screen.width + "; screen-height:" + screen.height);
            break;
    　　case -90:
            alert("左旋 -90,screen-width: " + screen.width + "; screen-height:" + screen.height);
            break;
    　　case 90:
            alert("右旋 90,screen-width: " + screen.width + "; screen-height:" + screen.height);
            break;
    　　case 180:
        　　alert("风景模式 180,screen-width: " + screen.width + "; screen-height:" + screen.height);
        　　break;
    };};

    addEventListener('load', function(){
    orientationChange();
    window.onorientationchange = orientationChange;
});

JS 单击延迟 click 事件因为要等待单击确认，会有 300ms 的延迟，体验并不是很好。
建议使用fastclick来解决https://github.com/ftlabs/fastclick
确保在点击功能之后添加event.stopPropagation();和/或event.preventDefault();直接添加，否则它可能会像我一样运行两次，即：
$("#buttonId").on('click',function(event){
    event.stopPropagation(); event.preventDefault();
   //do your magic
});
https://github.com/baijunjie/noclickdelay.js/blob/master/noclickdelay.js

有这样一种需求，需要判断用户照片是横着拍出来的还是竖着拍出来的，这里需要使用照片得exif信息：
https://github.com/exif-js/exif-js
$("input").change(function() {
    var file = this.files[0];
    fr   = new FileReader;
    fr.onloadend = function() {
        var exif = EXIF.readFromBinaryFile(new BinaryFile(this.result));
        alert(exif.Orientation);
    };
    fr.readAsBinaryString(file);
});
https://github.com/jseidelin/binaryajax/blob/master/binaryajax.js

要让a链接的CSS active伪类生效，只需要给这个a链接的touch系列的任意事件touchstart/touchend绑定一个空的匿名方法即可hack成功
<style>
a {
color: #000;
}
a:active {
color: #fff;
}
</style>
<a herf=”asdasd”>asdasd</a>
<script>
var a=document.getElementsByTagName(‘a’);
for(var i=0;i<a.length;i++){
a[i].addEventListener(‘touchstart’,function(){},false);
}
</script>

判断是否支持localStorage
try{
    if('localStorage' in window){
         //需要使用localStorage的代码写在这
    }else{
         //不支持的提示和向下兼容代码
    }
}catch(e){
    // 隐私模式相关提示代码和不支持的提示和向下兼容代码
}

安卓手机点击锁定页面效果问题
function touchHandlerDummy(e)
{
    e.preventDefault();
    return false;
}
document.addEventListener("touchstart", touchHandlerDummy, false);
document.addEventListener("touchmove", touchHandlerDummy, false);
document.addEventListener("touchend", touchHandlerDummy, false);

判断用户是否是“将网页添加到主屏后，再从主屏幕打开这个网页”的
navigator.standalone

隐藏地址栏 & 处理事件的时候，防止滚动条出现：
addEventListener('load', function(){
        setTimeout(function(){ window.scrollTo(0, 1); }, 100);
});

ios7 可以通过meta标签的minimal来隐藏地址栏了 http://darkblue.sdf.org/weblog/ios-7-dot-1-mobile-safari-minimal-ui.html
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, minimal-ui" />

判断是否为iPhone：
function isAppleMobile() {
    return (navigator.platform.indexOf('iPhone') != -1);
};

Cache开启和设置
browser.getSettings().setAppCacheEnabled(true);
browser.getSettings().setAppCachePath("/data/data/[com.packagename]/cache");
browser.getSettings().setAppCacheMaxSize(5*1024*1024); // 5MB

LocalStorage相关设置
browser.getSettings().setDatabaseEnabled(true);
browser.getSettings().setDomStorageEnabled(true);
String databasePath = browser.getContext().getDir("databases", Context.MODE_PRIVATE).getPath();
browser.getSettings().setDatabasePath(databasePath);//Android　webview的LocalStorage有个问题，关闭APP或者重启后，就清楚了，所以需要browser.getSettings().setDatabase相关的操作，把LocalStoarge存到DB中
myWebView.setWebChromeClient(new WebChromeClient(){
　　　 @Override
　　　 public void onExceededDatabaseQuota(String url, String databaseIdentifier, long currentQuota, long estimatedSize, long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater)
　　　 {
　　　　　　　 quotaUpdater.updateQuota(estimatedSize * 2);
　　　 }
}

浏览器自带缩放按钮取消显示
browser.getSettings().setBuiltInZoomControls(false);

iOS下的 Fixed + Input BUG现象
http://efe.baidu.com/blog/mobile-fixed-layout/

QQ浏览器X5内核问题汇总
https://www.qianduan.net/qqliu-lan-qi-x5nei-he-wen-ti-hui-zong/

=================================================
1. 如何隐藏所有指定元素？

const hide = (...el) => [...el].forEach(e => (e.style.display = 'none'));
// Example
hide(document.querySelectorAll('img')); // 隐藏页面上的所有 <img> 元素
 2. 如何确认元素是否具有指定的类？
const hasClass = (el, className) => el.classList.contains(className);
// Example
hasClass(document.querySelector('p.special'), 'special'); // true
 3. 如何切换元素的类？

const toggleClass = (el, className) => el.classList.toggle(className);
// Example
toggleClass(document.querySelector('p.special'), 'special'); 
// 该段不再有 'special' 类
 4. 如何获取当前页面的滚动位置？

const getScrollPosition = (el = window) => ({
  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
});
// Example
getScrollPosition(); // {x: 0, y: 200}
 5. 如何平滑滚动到页面顶部？

const scrollToTop = () => {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
};
// Example
scrollToTop();
 6. 如何确认父元素是否包含子元素？

const elementContains = (parent, child) => parent !== child && parent.contains(child);
// Examples
elementContains(document.querySelector('head'), document.querySelector('title')); 
// true
elementContains(document.querySelector('body'), document.querySelector('body')); // false
 7. 如何确认指定元素是否在视口可见？

const elementIsVisibleInViewport = (el, partiallyVisible = false) => {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return partiallyVisible
    ? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&
        ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))
    : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;
};
// Examples
elementIsVisibleInViewport(el); // (不完全可见)
elementIsVisibleInViewport(el, true); // (部分可见)
 8. 如何获取一个元素内的所有图像？

const getImages = (el, includeDuplicates = false) => {
  const images = [...el.getElementsByTagName('img')].map(img => img.getAttribute('src'));
  return includeDuplicates ? images : [...new Set(images)];
};
// Examples
getImages(document, true); // ['image1.jpg', 'image2.png', 'image1.png', '...']
getImages(document, false); // ['image1.jpg', 'image2.png', '...']
 9. 如何分辨设备是移动设备还是桌面设备？

const detectDeviceType = () =>
  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    ? 'Mobile'
    : 'Desktop';
// Example
detectDeviceType(); // "Mobile" or "Desktop"
 10. 如何获取当前 URL？

const currentURL = () => window.location.href;
// Example
currentURL(); // 'https://google.com'
 11. 如何创建一个包含当前 URL 参数的对象？

const getURLParameters = url =>
  (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(
    (a, v) => ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a),
    {}
  );
// Examples
getURLParameters('http://url.com/page?n=Adam&s=Smith'); // {n: 'Adam', s: 'Smith'}
getURLParameters('google.com'); // {}
 12. 如何将一组表单元素编码为一个对象？

const formToObject = form =>
  Array.from(new FormData(form)).reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
// Example
formToObject(document.querySelector('#form')); // { email: 'test@email.com', name: 'Test Name' }
 13. 如何从对象中检索给定选择器指示的一组属性？
const get = (from, ...selectors) =>
  [...selectors].map(s =>
    s
      .replace(/\[([^\[\]]*)\]/g, '.$1.')
      .split('.')
      .filter(t => t !== '')
      .reduce((prev, cur) => prev && prev[cur], from)
  );
const obj = { selector: { to: { val: 'val to select' } }, target: [1, 2, { a: 'test' }] };
// Example
get(obj, 'selector.to.val', 'target[0]', 'target[2].a'); // ['val to select', 1, 'test']
 14. 如何在等待一定时间后调用提供的函数（单位毫秒）？

const delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args);
delay(
  function(text) {
    console.log(text);
  },
  1000,
  'later'
); 
// 一秒后记录 'later' 。
 15. 如何在给定元素上触发特定事件，且可选传递自定义数据？

const triggerEvent = (el, eventType, detail) =>
  el.dispatchEvent(new CustomEvent(eventType, { detail }));
// Examples
triggerEvent(document.getElementById('myId'), 'click');
triggerEvent(document.getElementById('myId'), 'click', { username: 'bob' });
 16. 如何移除一个元素的事件侦听器？

const off = (el, evt, fn, opts = false) => el.removeEventListener(evt, fn, opts);
const fn = () => console.log('!');
document.body.addEventListener('click', fn);
off(document.body, 'click', fn); // no longer logs '!' upon clicking on the page
 17. 如何获得给定毫秒数的可读格式？

const formatDuration = ms => {
  if (ms < 0) ms = -ms;
  const time = {
    day: Math.floor(ms / 86400000),
    hour: Math.floor(ms / 3600000) % 24,
    minute: Math.floor(ms / 60000) % 60,
    second: Math.floor(ms / 1000) % 60,
    millisecond: Math.floor(ms) % 1000
  };
  return Object.entries(time)
    .filter(val => val[1] !== 0)
    .map(([key, val]) => `${val} ${key}${val !== 1 ? 's' : ''}`)
    .join(', ');
};
// Examples
formatDuration(1001); // '1 second, 1 millisecond'
formatDuration(34325055574); // '397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds'
 18. 如何获取两个日期之间的天数间隔？

const getDaysDiffBetweenDates = (dateInitial, dateFinal) =>
  (dateFinal - dateInitial) / (1000 * 3600 * 24);
// Example
getDaysDiffBetweenDates(new Date('2017-12-13'), new Date('2017-12-22')); // 9
 19. 如何对传递的 URL 进行 GET 请求？

const httpGet = (url, callback, err = console.error) => {
  const request = new XMLHttpRequest();
  request.open('GET', url, true);
  request.onload = () => callback(request.responseText);
  request.onerror = () => err(request);
  request.send();
};
httpGet(
  'https://jsonplaceholder.typicode.com/posts/1',
  console.log
); 
// Logs: {"userId": 1, "id": 1, "title": "sample title", "body": "my text"}
 20. 如何对传递的 URL 进行 POST 请求？

const httpPost = (url, data, callback, err = console.error) => {
  const request = new XMLHttpRequest();
  request.open('POST', url, true);
  request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
  request.onload = () => callback(request.responseText);
  request.onerror = () => err(request);
  request.send(data);
};
const newPost = {
  userId: 1,
  id: 1337,
  title: 'Foo',
  body: 'bar bar bar'
};
const data = JSON.stringify(newPost);
httpPost(
  'https://jsonplaceholder.typicode.com/posts',
  data,
  console.log
); 
// Logs: {"userId": 1, "id": 1337, "title": "Foo", "body": "bar bar bar"}
 21. 如何为指定选择器创建具有指定范围、步长和持续时间的计时器？

const counter = (selector, start, end, step = 1, duration = 2000) => {
  let current = start,
    _step = (end - start) * step < 0 ? -step : step,
    timer = setInterval(() => {
      current += _step;
      document.querySelector(selector).innerHTML = current;
      if (current >= end) document.querySelector(selector).innerHTML = end;
      if (current >= end) clearInterval(timer);
    }, Math.abs(Math.floor(duration / (end - start))));
  return timer;
};
// Example
counter('#my-id', 1, 1000, 5, 2000); // 为 id="my-id" 的元素创建一个两秒的计时器
 22. 如何将一个字符串复制到剪贴板？

const copyToClipboard = str => {
  const el = document.createElement('textarea');
  el.value = str;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  const selected =
    document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);
  if (selected) {
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(selected);
  }
};
// Example
copyToClipboard('Lorem ipsum'); // 'Lorem ipsum' copied to clipboard.
 23. 如何确定页面的浏览器选项卡是否处于前台活跃状态？

const isBrowserTabFocused = () => !document.hidden;
// Example
isBrowserTabFocused(); // true
 24. 如果一个目录不存在，如何创建它？

const fs = require('fs');
const createDirIfNotExists = dir => (!fs.existsSync(dir) ? fs.mkdirSync(dir) : undefined);
// Example
createDirIfNotExists('test'); // creates the directory 'test', if it doesn't exist

Array 数组

Array concatenation (数组拼接)

使用Array.concat()，通过在args中附加任何副本和/或值来拆分一个数组。
JavaScript代码：
const ArrayConcat = （arr ，... args ）=> []。concat （arr ，... args ）;        
// ArrayConcat（[1 ,, [1,2,3，[4]]）-> [1,2,3，[4]]
Array difference (数组比较)

根据副本b创建一个Set对象，然后在上方a上使用Array.filter()方法，过滤出数组b中不包含的值。
JavaScript代码：
const difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x)); };
// difference([1,2,3], [1,2]) -> [3]
Array includes (数组包含)

使用 slice() 来抵消数组/字符串，并且使用 indexOf() 来检查是否包含该值。如果省略最后一个参数 fromIndex ，则会检查整个数组/字符串。
JavaScript 代码:
const includes = (collection, val, fromIndex=0) => collection.slice(fromIndex).indexOf(val) != -1;
// includes("30-seconds-of-code", "code") -> true
// includes([1, 2, 3, 4], [1, 2], 1) -> false
Array intersection (数组交集)

根据数组 b 创建一个 Set 对象，然后在数组 a 上使用 Array.filter() 方法，只保留数组 b 中也包含的值。
JavaScript 代码:
const intersection = (a, b) => { const s = new Set(b); return a.filter(x => s.has(x)); };
// intersection([1,2,3], [4,3,2]) -> [2,3]
Array remove (移除数组中的元素)

使用 Array.filter() 和 Array.reduce() 来查找返回真值的数组元素，使用 Array.splice() 来移除元素。func 有三个参数(value, index, array)。
JavaScript 代码:
const remove = (arr, func) =>
  Array.isArray(arr) ? arr.filter(func).reduce((acc, val) => {
    arr.splice(arr.indexOf(val), 1); return acc.concat(val);
    }, [])
  : [];
//remove([1, 2, 3, 4], n => n % 2 == 0) -> [2, 4]
Array sample (数组取样随，机获取数组中的1个元素)

使用 Math.random() 生成一个随机数，乘以 length，并使用 Math.floor() 舍去小数获得到最接近的整数。这个方法也适用于字符串。
JavaScript 代码:
const sample = arr => arr[Math.floor(Math.random() * arr.length)];
// sample([3, 7, 9, 11]) -> 9
Array union (数组合集)

用数组 a 和 b 的所有值创建一个 Set 对象，并转换成一个数组。
JavaScript 代码:
const union = (a, b) => Array.from(new Set([...a, ...b]));
// union([1,2,3], [4,3,2]) -> [1,2,3,4]
Array without (从数组中排除给定值)

使用 Array.filter() 创建一个排除所有给定值的数组。
JavaScript 代码:
const without = (arr, ...args) => arr.filter(v => args.indexOf(v) === -1);
// without([2, 1, 2, 3], 1, 2) -> [3]
// without([2, 1, 2, 3, 4, 5, 5, 5, 3, 2, 7, 7], 3, 1, 5, 2) -> [ 4, 7, 7 ]
Array zip (创建一个分组元素数组)

使用 Math.max.apply() 获取参数中最长的数组。创建一个长度为返回值的数组，并使用 Array.from() 和 map-function 来创建一个分组元素数组。如果参数数组的长度不同，则在未找到值的情况下使用 undefined 。
JavaScript 代码:
const zip = (...arrays) => {
  const maxLength = Math.max.apply(null, arrays.map(a => a.length));
  return Array.from({length: maxLength}).map((_, i) => {
   return Array.from({length: arrays.length}, (_, k) => arrays[k][i]);
  })
}
//zip(['a', 'b'], [1, 2], [true, false]); -> [['a', 1, true], ['b', 2, false]]
//zip(['a'], [1, 2], [true, false]); -> [['a', 1, true], [undefined, 2, false]]
Average of array of numbers (求数字数组的平均数)

使用 Array.reduce() 将数组中的每个值添加到一个累加器，使用 0 初始化，除以数组的 length (长度)。
JavaScript 代码:
const average = arr => arr.reduce((acc, val) => acc + val, 0) / arr.length;
// average([1,2,3]) -> 2
Chunk array (数组分块)

使用 Array.from() 创建一个新的数组，它的长度与将要生成的 chunk(块) 数量相匹配。使用 Array.slice() 将新数组的每个元素映射到长度为 size 的 chunk 中。如果原始数组不能均匀分割，最后的 chunk 将包含剩余的元素。
JavaScript 代码:
const chunk = (arr, size) =>
  Array.from({length: Math.ceil(arr.length / size)}, (v, i) => arr.slice(i * size, i * size + size));
// chunk([1,2,3,4,5], 2) -> [[1,2],[3,4],[5]]
Compact (过滤掉数组中所有假值元素)

使用 Array.filter() 过滤掉数组中所有 假值元素(false, null, 0, "", undefined, and NaN)。
JavaScript 代码:
const compact = (arr) => arr.filter(v => v);
// compact([0, 1, false, 2, '', 3, 'a', 'e'*23, NaN, 's', 34]) -> [ 1, 2, 3, 'a', 's', 34 ]
Count occurrences of a value in array (计数数组中某个值的出现次数)

每次遇到数组中的指定值时，使用 Array.reduce() 来递增计数器。
JavaScript 代码:
const countOccurrences = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0);
// countOccurrences([1,1,2,1,2,3], 1) -> 3
Deep flatten array (深度平铺数组)

使用递归。通过空数组([]) 使用 Array.concat() ，结合 展开运算符( ... ) 来平铺数组。递归平铺每个数组元素。
JavaScript 代码:
const deepFlatten = arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v));
// deepFlatten([1,[2],[[3],4],5]) -> [1,2,3,4,5]
Drop elements in array (删除数组中的元素)

循环数组，使用 Array.shift() 删除数组的第一个元素，直到函数的返回值为 true 。返回其余的元素。
JavaScript 代码:
const dropElements = (arr, func) => {
  while (arr.length > 0 && !func(arr[0])) arr.shift();
  return arr;
};
// dropElements([1, 2, 3, 4], n => n >= 3) -> [3,4]
Fill array (填充数组)

使用 Array.map() 将指定值映射到 start(包含)和 end (排除)之间。省略 start 将从第一个元素开始，省略 end 将在最后一个元素完成。
JavaScript 代码:
const fillArray = (arr, value, start = 0, end = arr.length) =>
  arr.map((v, i) => i >= start && i < end ? value : v);
// fillArray([1,2,3,4],'8',1,3) -> [1,'8','8',4]
Filter out non-unique values in an array (过滤出数组中的非唯一值)

使用 Array.filter() 滤除掉非唯一值，使数组仅包含唯一值。
JavaScript 代码:
const filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));
// filterNonUnique([1,2,2,3,4,4,5]) -> [1,3,5]
Flatten array up to depth (根据指定的 depth 平铺数组)

每次递归，使 depth 减 1 。使用 Array.reduce() 和 Array.concat() 来合并元素或数组。默认情况下， depth 等于 1 时停递归。省略第二个参数 depth ，只能平铺1层的深度 (单层平铺)。
JavaScript 代码:
const flattenDepth = (arr, depth = 1) =>
  depth != 1 ? arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), [])
  : arr.reduce((a, v) => a.concat(v), []);
// flattenDepth([1,[2],[[[3],4],5]], 2) -> [1,2,[3],4,5]
Flatten array (平铺数组)

使用 Array.reduce() 获取数组中的所有元素，并使用 concat() 将其平铺。
JavaScript 代码:
const flatten = arr => arr.reduce((a, v) => a.concat(v), []);
// flatten([1,[2],3,4]) -> [1,2,3,4]
Get max value from array (获取数组中的最大值)

结合使用 Math.max() 与 展开运算符( ... )，获取数组中的最大值。
JavaScript 代码:
const arrayMax = arr => Math.max(...arr);
// arrayMax([10, 1, 5]) -> 10
Get min value from array (获取数组中的最小值)

结合使用 Math.max() 与 展开运算符( ... )，获取数组中的最小值。
JavaScript 代码:
const arrayMin = arr => Math.min(...arr);
// arrayMin([10, 1, 5]) -> 1
Group by (数组分组)

使用 Array.map() 将数组的值映射到函数或属性名称。使用 Array.reduce() 来创建一个对象，其中的 key 是从映射结果中产生。
JavaScript 代码:
const groupBy = (arr, func) =>
  arr.map(typeof func === 'function' ? func : val => val[func])
    .reduce((acc, val, i) => { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {});
// groupBy([6.1, 4.2, 6.3], Math.floor) -> {4: [4.2], 6: [6.1, 6.3]}
// groupBy(['one', 'two', 'three'], 'length') -> {3: ['one', 'two'], 5: ['three']}
Head of list (获取数组的第一个元素)

使用 arr[0] 返回传递数组的第一个元素。
JavaScript 代码:
const head = arr => arr[0];
// head([1,2,3]) -> 1
Initial of list (排除数组中最后一个元素)

使用 arr.slice(0,-1) 返回排除了最后一个元素的数组。
JavaScript 代码:
const initial = arr => arr.slice(0, -1);
// initial([1,2,3]) -> [1,2]
Initialize array with range (初始化特定范围的数组)

使用 Array(end-start) 创建所需长度的数组，使用 Array.map() 在一个范围内填充所需的值。
您可以省略 start ，默认值 0。
JavaScript 代码:
const initializeArrayRange = (end, start = 0) =>
  Array.apply(null, Array(end - start)).map((v, i) => i + start);
// initializeArrayRange(5) -> [0,1,2,3,4]
Initialize array with values (初始化特定范围和值的数组)

使用 Array(n) 创建所需长度的数组，使用 fill(v) 以填充所需的值。您可以忽略 value ，使用默认值 0 。
JavaScript 代码:
const initializeArray = (n, value = 0) => Array(n).fill(value);
// initializeArray(5, 2) -> [2,2,2,2,2]
Last of list (获取数组的最后一个元素)

使用 arr.slice(-1)[0] 来获取给定数组的最后一个元素。
JavaScript 代码:
const last = arr => arr.slice(-1)[0];
// last([1,2,3]) -> 3
Median of array of numbers (获取数字数组的中值)

找到数字数组的中间值，使用 Array.sort() 对值进行排序。如果 length 是奇数，则返回中间值数字，否则返回两个中间值数值的平均值。
JavaScript 代码:
const median = arr => {
  const mid = Math.floor(arr.length / 2), nums = arr.sort((a, b) => a - b);
  return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
// median([5,6,50,1,-5]) -> 5
// median([0,10,-2,7]) -> 3.5
Nth element of array (获取数组的第N个元素)

使用 Array.slice() 获取数组的第 n 个元素。如果索引超出范围，则返回 [] 。省略第二个参数 n ，将得到数组的第一个元素。
JavaScript 代码:
const nth = (arr, n=0) => (n>0? arr.slice(n,n+1) : arr.slice(n))[0];
// nth(['a','b','c'],1) -> 'b'
// nth(['a','b','b']-2) -> 'a'
Pick(提取)

使用 Array.reduce() 只 过滤/萃取 出 arr 参数指定 key (如果 key 存在于 obj 中)的属性值，。
JavaScript 代码:
const pick = (obj, arr) =>
  arr.reduce((acc, curr) => (curr in obj && (acc[curr] = obj[curr]), acc), {});
// pick({ 'a': 1, 'b': '2', 'c': 3 }, ['a', 'c']) -> { 'a': 1, 'c': 3 }
// pick(object, ['a', 'c'])['a'] -> 1
Shuffle array (随机排列数组)

使用 Array.sort() 来重新排序元素，比较器中使用 Math.random() 。
JavaScript 代码:
const shuffle = arr => arr.sort(() => Math.random() - 0.5);
// shuffle([1,2,3]) -> [2,3,1]
Similarity between arrays (获取数组交集)

使用 filter() 移除不在 values 中的值，使用 includes() 确定。
JavaScript 代码:
const similarity = (arr, values) => arr.filter(v => values.includes(v));
// similarity([1,2,3], [1,2,4]) -> [1,2]
Sum of array of numbers (数字数组求和)

使用 Array.reduce() 将每个值添加到累加器，并使用0值初始化。
JavaScript 代码:
const sum = arr => arr.reduce((acc, val) => acc + val, 0);
// sum([1,2,3,4]) -> 10
Tail of list (返回剔除第一个元素后的数组)

如果数组的 length 大于 1 ，则返回 arr.slice(1)，否则返回整个数组。
JavaScript 代码:
const tail = arr => arr.length > 1 ? arr.slice(1) : arr;
// tail([1,2,3]) -> [2,3]
// tail([1]) -> [1]
Take right(从一个给定的数组中创建一个后N个元素的数组)

使用 Array.slice() 来创建一个从第 n 个元素开始从末尾的数组。
JavaScript 代码:
const takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);
// takeRight([1, 2, 3], 2) -> [ 2, 3 ]
// takeRight([1, 2, 3]) -> [3]
Take(从一个给定的数组中创建一个前N个元素的数组)

使用 Array.slice() 创建一个数组包含第一个元素开始，到 n 个元素结束的数组。
JavaScript 代码:
const take = (arr, n = 1) => arr.slice(0, n);
// take([1, 2, 3], 5) -> [1, 2, 3]
// take([1, 2, 3], 0) -> []
Unique values of array (数组去重)

使用 ES6 的 Set 和 ...rest 操作符剔除重复的值。
JavaScript 代码:
const unique = arr => [...new Set(arr)];
// unique([1,2,2,3,4,4,5]) -> [1,2,3,4,5]
Browser 浏览器

Bottom visible (页面的底部是否可见)

使用 scrollY，scrollHeight 和 clientHeight 来确定页面的底部是否可见。
JavaScript 代码:
const bottomVisible = _ =>
  document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight || document.documentElement.clientHeight;
// bottomVisible() -> true
Current URL (获取当前页面URL)

使用 window.location.href 获取当前页面URL。
JavaScript 代码:
const currentUrl = _ => window.location.href;
// currentUrl() -> 'https://google.com'
Element is visible in viewport (判断元素是否在可视窗口可见)

使用 Element.getBoundingClientRect() 和 window.inner(Width|Height) 值来确定给定元素是否在可视窗口中可见。省略第二个参数来判断元素是否完全可见，或者指定 true 来判断它是否部分可见。
JavaScript 代码:
const elementIsVisibleInViewport = (el, partiallyVisible = false) => {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  return partiallyVisible
    ? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&
      ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))
    : top >= 0 && left >= 0 && bottom < = innerHeight && right <= innerWidth;
};
// 举个例子，有一个 100x100 可视窗口， 和一个 10x10px 元素定位在 {top: -1, left: 0, bottom: 9, right: 10}
// elementIsVisibleInViewport(el) -> false (not fully visible)
// elementIsVisibleInViewport(el, true) -> true (partially visible)
Get scroll position (获取滚动条位置)

如果浏览器支持 pageXOffset 和 pageYOffset ，那么请使用 pageXOffset 和 pageYOffset ，否则请使用 scrollLeft 和 scrollTop 。你可以省略 el 参数，默认值为 window。
JavaScript 代码:
const getScrollPos = (el = window) =>
  ({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,
    y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});
// getScrollPos() -> {x: 0, y: 200}
Redirect to URL (重定向到URL)

使用 window.location.href 或 window.location.replace() 重定向到 url 。传递第二个参数来模拟链接点击(true – 默认值)或HTTP重定向(false)。
JavaScript 代码:
const redirect = (url, asLink = true) =>
  asLink ? window.location.href = url : window.location.replace(url);
// redirect('https://google.com')
Scroll to top (回到顶部)

使用 document.documentElement.scrollTop 或 document.body.scrollTop 获取到顶部距离。从顶部滚动一小部分距离。使用window.requestAnimationFrame() 来实现滚动动画。
JavaScript 代码:
const scrollToTop = _ => {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
};
// scrollToTop()
Date 日期

Get days difference between dates (获取两个日期之间相差的天数)

计算 Date 对象之间的差异(以天为单位)。
JavaScript 代码:
const getDaysDiffBetweenDates = (dateInitial, dateFinal) => (dateFinal - dateInitial) / (1000 * 3600 * 24);
// getDaysDiffBetweenDates(new Date("2017-12-13"), new Date("2017-12-22")) -> 9
Function 函数

Chain asynchronous functions (链式调用异步函数)

循环遍历包含异步事件的函数数组，每次异步事件完成后调用 next 。
JavaScript 代码:
const chainAsync = fns => { let curr = 0; const next = () => fns[curr++](next); next(); };
/*
chainAsync([
  next => { console.log('0 seconds'); setTimeout(next, 1000); },
  next => { console.log('1 second');  setTimeout(next, 1000); },
  next => { console.log('2 seconds'); }
])
*/
Curry (函数式编程术语：柯里化)

使用递归。如果提供的参数(args)数量足够，调用传递函数 fn 。否则返回一个柯里化后的函数 fn ，期望剩下的参数。
如果你想柯里化一个接受可变参数数量的函数(可变参数数量的函数，例如 Math.min() )，你可以选择将参数个数传递给第二个参数 arity。
JavaScript 代码:
const curry = (fn, arity = fn.length, ...args) =>
  arity < = args.length
    ? fn(...args)
    : curry.bind(null, fn, arity, ...args);
// curry(Math.pow)(2)(10) -> 1024
// curry(Math.min, 3)(10)(50)(2) -> 2
Pipe (函数式编程术语：管道或导流)

使用 Array.reduce() 来执行从左到右的函数组合。第一个(最左边的)函数可以接受一个或多个参数；其余的函数必须是一元函数。
JavaScript 代码:
const pipe = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));
/*
const add5 = x => x + 5
const multiply = (x, y) => x * y
const multiplyAndAdd5 = pipe(multiply, add5)
multiplyAndAdd5(5, 2) -> 15
*/
Promisify (柯里化一个 Promise 函数)

使用柯里化返回一个函数，这个函数返回一个调用原始函数的 Promise 。使用 ...rest 运算符传入所有参数。
在 Node 8+ 中，你可以使用 util.promisify
JavaScript 代码:
const promisify = func =>
  (...args) =>
    new Promise((resolve, reject) =>
      func(...args, (err, result) =>
        err ? reject(err) : resolve(result))
    );
// const delay = promisify((d, cb) => setTimeout(cb, d))
// delay(2000).then(() => console.log('Hi!')) -> Promise resolves after 2s
Run promises in series (运行连续的 promises)

使用 Array.reduce() 通过创建 promise 链来运行连续的 promises，其中每个 promise 在 resolved 时返回下一个 promise 。
JavaScript 代码:
const series = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());
// const delay = (d) => new Promise(r => setTimeout(r, d))
// series([() => delay(1000), () => delay(2000)]) -> executes each promise sequentially, taking a total of 3 seconds to complete
Sleep (休眠)

延迟执行 async 函数的一部分，通过把它放到 sleep 状态，返回一个 Promise 。
JavaScript 代码:
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
/*
async function sleepyWork() {
  console.log('I\'m going to sleep for 1 second.');
  await sleep(1000);
  console.log('I woke up after 1 second.');
}
*/
Math 数学方法

Collatz algorithm(考拉兹算法)

如果 n 是偶数，则返回 n/2 。否则返回 3n+1 。
JavaScript 代码:
const collatz = n => (n % 2 == 0) ? (n / 2) : (3 * n + 1);
// collatz(8) --> 4
// collatz(5) --> 16
注：考拉兹猜想(英语：Collatz conjecture)，又称为奇偶归一猜想、3n＋1猜想、冰雹猜想、角谷猜想、哈塞猜想、乌拉姆猜想或叙拉古猜想，是指对于每一个正整数，如果它是奇数，则对它乘3再加1，如果它是偶数，则对它除以2，如此循环，最终都能够得到1。– 维基百科。
Distance between two points (两点之间的欧氏距离)

使用 Math.hypot() 计算两点之间的欧氏距离( Euclidean distance)。
JavaScript 代码:
const distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);
// distance(1,1, 2,3) -> 2.23606797749979
注：欧氏距离( Euclidean distance)是一个通常采用的距离定义，它是在m维空间中两个点之间的真实距离。
Divisible by number (可以被某个数整除)

使用模运算符(%)来检查余数是否等于 0 。
JavaScript 代码:
const isDivisible = (dividend, divisor) => dividend % divisor === 0;
// isDivisible(6,3) -> true
Even or odd number (判断奇偶数)

使用模运算符(%)来检查数字是奇数还是偶数。如果数字是偶数，则返回 true ，如果是奇数，则返回 false 。
JavaScript 代码:
const isEven = num => num % 2 === 0;
// isEven(3) -> false
Factorial (阶乘)

使用递归。如果 n 小于或等于 1 ，则返回 1 。否则返回 n 和 n - 1 的阶乘。
JavaScript 代码:
const factorial = n => n < = 1 ? 1 : n * factorial(n - 1);
// factorial(6) -> 720
Fibonacci array generator (斐波纳契数组发生器)

创建一个指定长度的空数组，初始化前两个值( 0 和 1 )。使用 Array.reduce() 向数组中添加值，使用最的值是两个值的和(前两个除外)。
JavaScript 代码:
const fibonacci = n =>
  Array(n).fill(0).reduce((acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i), []);
// fibonacci(5) -> [0,1,1,2,3]
Greatest common divisor (GCD) (最大公约数)

使用递归。当 y 等于 0 的情况下，返回 x 。否则，返回 y 和 x/y 余数最大公约数。
JavaScript 代码:
const gcd = (x, y) => !y ? x : gcd(y, x % y);
// gcd (8, 36) -> 4
Hamming distance (汉明距离)

使用XOR运算符( ^ )查找这两个数字之间的位差，使用 toString(2) 转换为二进制字符串。使用 match(/1/g) 计算并返回字符串中 1 的数量。
JavaScript 代码:
const hammingDistance = (num1, num2) =>
  ((num1 ^ num2).toString(2).match(/1/g) || '').length;
// hammingDistance(2,3) -> 1
注：在信息论中，两个等长字符串之间的汉明距离(英语：Hamming distance)是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。- 维基百科
Percentile (百分比)

使用 Array.reduce() 来计算有多少数字小于等于该值，并用百分比表示。
JavaScript 代码:
const percentile = (arr, val) => 
  100 * arr.reduce((acc,v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0) / arr.length;
// percentile([1,2,3,4,5,6,7,8,9,10], 6) -> 55
Powerset (幂集)

使用 Array.reduce() 与 Array.map() 结合来遍历元素，并将其组合成一个包含所有排列组合的数组。
JavaScript 代码:
const powerset = arr =>
  arr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);
// powerset([1,2]) -> [[], [1], [2], [2,1]]
Round number to n digits (精确的几位小数)

使用 Math.round() 和模板字面量将数字四舍五入为指定的小数位数。省略第二个参数 decimals ，数字将被四舍五入到一个整数。
JavaScript 代码:
const round = (n, decimals=0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);
// round(1.005, 2) -> 1.01
Standard deviation (标准偏差)

使用 Array.reduce() 来计算均值，方差已经值的方差之和，方差的值，然后确定标准偏差。您可以省略第二个参数来获取样本标准偏差，或将其设置为 true 以获得总体标准偏差。
JavaScript 代码:
const standardDeviation = (arr, usePopulation = false) => {
  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;
  return Math.sqrt(
    arr.reduce((acc, val) => acc.concat(Math.pow(val - mean, 2)), [])
       .reduce((acc, val) => acc + val, 0) / (arr.length - (usePopulation ? 0 : 1))
  );
};
// standardDeviation([10,2,38,23,38,23,21]) -> 13.284434142114991 (sample)
// standardDeviation([10,2,38,23,38,23,21], true) -> 12.29899614287479 (population)
Media 媒体

Speech synthesis (语音合成，实验阶段)

使用 SpeechSynthesisUtterance.voice 和 indow.speechSynthesis.getVoices() 将消息转换为语音。使用 window.speechSynthesis.speak() 播放消息。
了解有关Web Speech API的SpeechSynthesisUtterance接口的更多信息。
JavaScript 代码:
const speak = message => {
  const msg = new SpeechSynthesisUtterance(message);
  msg.voice = window.speechSynthesis.getVoices()[0];
  window.speechSynthesis.speak(msg);
};
// speak('Hello, World') -> plays the message
Node

Write JSON to file (将 JSON 写到文件)

使用 fs.writeFile()，模板字面量 和 JSON.stringify() 将 json 对象写入到 .json 文件中。
JavaScript 代码:
const fs = require('fs');
const jsonToFile = (obj, filename) => fs.writeFile(`${filename}.json`, JSON.stringify(obj, null, 2))
// jsonToFile({test: "is passed"}, 'testJsonFile') -> writes the object to 'testJsonFile.json'
Object 对象

Object from key-value pairs (根据键值对创建对象)

使用 Array.reduce() 来创建和组合键值对。
JavaScript 代码:
const objectFromPairs = arr => arr.reduce((a, v) => (a[v[0]] = v[1], a), {});
// objectFromPairs([['a',1],['b',2]]) -> {a: 1, b: 2}
Object to key-value pairs (对象转化为键值对 )

使用 Object.keys() 和 Array.map() 遍历对象的键并生成一个包含键值对的数组。
JavaScript 代码:
const objectToPairs = obj => Object.keys(obj).map(k => [k, obj[k]]);
// objectToPairs({a: 1, b: 2}) -> [['a',1],['b',2]])
Shallow clone object (浅克隆对象)

使用 Object.assign() 和一个空对象({})来创建原始对象的浅拷贝。
JavaScript 代码:
const shallowClone = obj => Object.assign({}, obj);
/*
const a = { x: true, y: 1 };
const b = shallowClone(a);
a === b -> false
*/
注：JavaScript 中的对象拷贝方法有很多，这里有个总结，有兴趣可以看一下：https://www.html.cn/archives/8319
String 字符串

Anagrams of string (with duplicates) (字符串的排列组合，带有重复项)

使用递归。对于给定字符串中的每个字母，为其余字母创建所有部分字母。使用 Array.map() 将字母与每个部分字母组合在一起，然后使用 Array.reduce() 将所有字母组合到一个数组中。基本情况是字符串 length 等于 2 或 1 。
JavaScript 代码:
const anagrams = str => {
  if (str.length < = 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];
  return str.split('').reduce((acc, letter, i) =>
    acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), []);
};
// anagrams('abc') -> ['abc','acb','bac','bca','cab','cba']
Capitalize first letter of every word (大写每个单词的首字母)

使用 replace() 来匹配每个单词的第一个字符，并使用 toUpperCase() 来将其大写。
JavaScript 代码:
const capitalizeEveryWord = str => str.replace(/\b[a-z]/g, char => char.toUpperCase());
// capitalizeEveryWord('hello world!') -> 'Hello World!'
Capitalize first letter (首字母大写)

使用解构和 toUpperCase() 大写第一个字母，...rest 第一个字母后获得字符数组，然后 Array.join('')再次使它成为一个字符串。省略 lowerRest 参数以保持字符串的剩余部分不变，或者将其设置为 true 这会将字符串的剩余部分转换为小写。
JavaScript 代码:
const capitalize = ([first,...rest], lowerRest = false) =>
  first.toUpperCase() + (lowerRest ? rest.join('').toLowerCase() : rest.join(''));
// capitalize('myName') -> 'MyName'
// capitalize('myName', true) -> 'Myname'
Check for palindrome (检查回文)

使用 toLowerCase() 转换字符串，并使用 replace() 从中删除非字母数字字符。然后，在将其转换为 tolowerCase() 之后，将 split('') 为单独的字符，reverse() ，join('')并与原始非反转字符串进行比较。
JavaScript 代码:
const palindrome = str => {
  const s = str.toLowerCase().replace(/[\W_]/g,'');
  return s === s.split('').reverse().join('');
}
// palindrome('taco cat') -> true
Reverse a string (反转一个字符串)

使用数组解构和 Array.reverse() 来反转字符串中字符的顺序。使用 join('')合并字符串。
JavaScript 代码:
const reverseString = str => [...str].reverse().join('');
// reverseString('foobar') -> 'raboof'
Sort characters in string (alphabetical) (按字母顺序排列字符串)

使用 split('') 分割字符串，通过 localeCompare() 排序字符串 Array.sort() ，使用 join('') 进行重组。
JavaScript 代码:
const sortCharactersInString = str =>
  str.split('').sort((a, b) => a.localeCompare(b)).join('');
// sortCharactersInString('cabbage') -> 'aabbceg'
Truncate a String (截断一个字符串)

确定字符串的 length 是否大于 num。返回截断所需长度的字符串，用 ... 附加到结尾或原始字符串。
JavaScript 代码:
const truncate = (str, num) =>
  str.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;
// truncate('boomerang', 7) -> 'boom...'
Utility 实用函数

Escape regular expression (转义正则表达式)

使用 replace() 来转义特殊字符。
JavaScript 代码:
const escapeRegExp = str => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
// escapeRegExp('(test)') -> \\(test\\)
Get native type of value (获取原生类型的值)

返回值小写的构造函数名称，如果值为 undefined 或 null ，则返回 “undefined” 或 “null”。
JavaScript 代码:
const getType = v =>
  v === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name.toLowerCase();
// getType(new Set([1,2,3])) -> "set"
Hexcode to RGB (Hex转RGB)

使用Array.slice() , Array.map() 和 match() 将十六进制颜色代码(前缀为#)转换为RGB值的字符串。
JavaScript 代码:
const hexToRgb = hex => `rgb(${hex.slice(1).match(/.{2}/g).map(x => parseInt(x, 16)).join()})`
// hexToRgb('#27ae60') -> 'rgb(39,174,96)'
Is array(是否为数组)

使用 Array.isArray() 来检查一个值是否为一个数组。
JavaScript 代码:
const isArray = val => !!val && Array.isArray(val);
// isArray(null) -> false
// isArray([1]) -> true
Is boolean(是否为布尔值)

使用 typeof 来检查一个值是否为一个布尔值。
JavaScript 代码:
const isBoolean = val => typeof val === 'boolean';
// isBoolean(null) -> false
// isBoolean(false) -> true
Is function(是否为函数)

使用 typeof 来检查一个值是否为一个函数。
JavaScript 代码:
const isFunction = val => val && typeof val === 'function';
// isFunction('x') -> false
// isFunction(x => x) -> true
Is number(是否为数字)

使用 typeof 来检查一个值是否为一个数字。
JavaScript 代码:
const isNumber = val => typeof val === 'number';
// isNumber('1') -> false
// isNumber(1) -> true
Is string(是否为字符串)

使用 typeof 来检查一个值是否为一个字符串。
JavaScript 代码:
const isString = val => typeof val === 'string';
// isString(10) -> false
// isString('10') -> true
Is symbol(是否为symbol)

使用 typeof 来检查一个值是否为一个 symbol 。
JavaScript 代码:
const isSymbol = val => typeof val === 'symbol';
// isSymbol('x') -> false
// isSymbol(Symbol('x')) -> true
Measure time taken by function (计算函数执行所花费的时间)

使用 console.time() 和 console.timeEnd() 来测量开始和结束时间之间的差，以确定回调执行的时间。
JavaScript 代码:
const timeTaken = callback => {
  console.time('timeTaken');
  const r = callback();
  console.timeEnd('timeTaken');
  return r;
};
// timeTaken(() => Math.pow(2, 10)) -> 1024
// (logged): timeTaken: 0.02099609375ms
Number to array of digits (将数字转化为整数数组)

将数字转换为字符串，使用 split() 来转换构建一个数组。使用 Array.map() 和 parseInt() 将每个值转换为整数。
JavaScript 代码:
const digitize = n => (''+n).split('').map(i => parseInt(i));
// digitize(2334) -> [2, 3, 3, 4]
Ordinal suffix of number (数字序号的后缀)

使用模运算符(%)来查找各位和十位的值。查找哪些序号模式数字匹配。如果数字在十位模式中找到，请使用十位的序数。
JavaScript 代码:
const toOrdinalSuffix = num => {
  const int = parseInt(num), digits = [(int % 10), (int % 100)],
    ordinals = ['st', 'nd', 'rd', 'th'], oPattern = [1, 2, 3, 4],
    tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];
  return oPattern.includes(digits[0]) && !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];
};
// toOrdinalSuffix("123") -> "123rd"
Random integer in range (在指定的范围内生成一个随机整数)

使用 Math.random() 生成一个随机数并将其映射到所需的范围，使用 Math.floor() 使其成为一个整数。
JavaScript 代码:
const randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
// randomIntegerInRange(0, 5) -> 2
Random number in range (在指定的范围内生成一个随机数)

使用 Math.random() 生成一个随机值，使用乘法将其映射到所需的范围。
JavaScript 代码:
const randomInRange = (min, max) => Math.random() * (max - min) + min;
// randomInRange(2,10) -> 6.0211363285087005
RGB to hexadecimal(RGB转hex)

使用按位左移运算符(<<)和 toString(16) 将给定的RGB参数转换为十六进制字符串，然后使用 padStart(6,'0') 得到一个6位的十六进制值。
JavaScript 代码:
const rgbToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');
// rgbToHex(255, 165, 1) -> 'ffa501'
Swap values of two variables (交换两个变量的值)

使用数组解构来交换两个变量之间的值。
JavaScript 代码:
[varA, varB] = [varB, varA];
// [x, y] = [y, x]
URL parameters(网址参数)

通过适当的正则表达式，使用 match() 来获得所有的键值对， Array.reduce() 来映射和组合成一个单一的对象。将 location.search 作为参数传递给当前 url。
JavaScript 代码:
const getUrlParameters = url =>
  url.match(/([^?=&]+)(=([^&]*))/g).reduce(
    (a, v) => (a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1), a), {}
  );
// getUrlParameters('http://url.com/page?name=Adam&surname=Smith') -> {name: 'Adam', surname: 'Smith'}
UUID generator (UUID生成器)

使用 crypto API 生成符一个 UUID，符合RFC4122 版本 4 。
JavaScript 代码:
const uuid = _ =>
  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
// uuid() -> '7982fcfe-5721-4632-bede-6000885be57d'
Validate email(邮箱验证)

使用正则表达式来检查电子邮件是否有效。如果电子邮件有效，则返回 true ，否则返回false 。
JavaScript 代码:
const validateEmail = str =>
  /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(str);
// validateEmail(mymail@gmail.com) -> true
Validate number (数字验证)

使用 !isNaN 和 parseFloat() 来检查参数是否是一个数字。使用 isFinite() 来检查数字是否是有限数。使用 Number() 来检查强制转换是否成立。
JavaScript 代码:
const validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;
// validateNumber('10') -> true
Value or default (值或者默认值)

返回 value ，如果传递的值是 falsy ，则返回默认值。
JavaScript 代码:
const valueOrDefault = (value, d) => value || d;
// valueOrDefault(NaN, 30) -> 30

1. 类型检查小工具
JavaScript 不是强类型语言，对此我推荐的最佳解决方案是 TypeScript。但有时你只是想要一个简单的类型检查，这种时候 JavaScript 允许你使用“typeof”关键字。
“typeof”的问题在于，将其用于某些原语和函数时效果很好，但对于数组和对象来说，由于它们都被视为“对象”，因此很难把握它们之间的区别。
const isOfType = (() => {
  // create a plain object with no prototype
  const type = Object.create(null);

  // check for null type
  type.null = x => x === null;
  // check for undefined type
  type.undefined = x => x === undefined;
  // check for nil type. Either null or undefined
  type.nil = x => type.null(x) || type.undefined(x);
  // check for strings and string literal type. e.g: 's', "s", `str`, new String()
  type.string = x => !type.nil(x) && (typeof x === 'string' || x instanceof String);
  // check for number or number literal type. e.g: 12, 30.5, new Number()
  type.number = x => !type.nil(x) 
    && (// NaN & Infinity have typeof "number" and this excludes that
      (!isNaN(x) && isFinite(x)
      && typeof x === 'number'
    ) || x instanceof Number);
  // check for boolean or boolean literal type. e.g: true, false, new Boolean()
  type.boolean = x => !type.nil(x) && (typeof x === 'boolean' || x instanceof Boolean);
  // check for array type
  type.array = x => !type.nil(x) && Array.isArray(x);
  // check for object or object literal type. e.g: {}, new Object(), Object.create(null)
  type.object = x => ({}).toString.call(x) === '[object Object]';
  // check for provided type instance
  type.type = (x, X) => !type.nil(x) && x instanceof X;
  // check for set type
  type.set = x => type.type(x, Set);
  // check for map type
  type.map = x => type.type(x, Map);
  // check for date type
  type.date = x => type.type(x, Date);

  return type;
})();
2. 检查是否为空
有时你需要知道某些内容是否为空，并根据结果决定要使用的方法，例如检查长度、大小或是否包含任何子元素。下面这个工具打包了这些功能，你可以用它检查 String、Object、Array、Map 和 Set 的大小。
function isEmpty(x) {
  if(Array.isArray(x)
    || typeof x === 'string'
    || x instanceof String
   ) {
    return x.length === 0;
  }

  if(x instanceof Map || x instanceof Set) {
    return x.size === 0;
  }

  if(({}).toString.call(x) === '[object Object]') {
    return Object.keys(x).length === 0;
  }

  return false;
}
3. 获取列表最后一项
其他语言里这个功能被做成了可以在数组上调用的方法或函数，但在 JavaScript 里面，你得自己做点工作。
function lastItem(list) {
  if(Array.isArray(list)) {
    return list.slice(-1)[0];
  }

  if(list instanceof Set) {
    return Array.from(list).slice(-1)[0];
  }

  if(list instanceof Map) {
    return Array.from(list.values()).slice(-1)[0];
  }
}
4. 带有范围的随机数生成器
有时你需要生成随机数，但希望这些数字在一定范围内，那就可以用这个工具。
function randomNumber(max = 1, min = 0) {
  if(min >= max) {
    return max;
  }

  return Math.floor(Math.random() * (max - min) + min);
}
5. 随机 ID 生成器
有时你只是需要一些 ID？除非你要的是更复杂的 ID 生成器（例如 UUID），否则用不着为此安装什么新库，下面这个选项足够了。你可以从当前时间（以毫秒为单位）或特定的整数和增量开始生成，也可以从字母生成 ID。
// create unique id starting from current time in milliseconds
// incrementing it by 1 everytime requested
const uniqueId = (() => {
  const id = (function*() {
    let mil = new Date().getTime();

    while (true)
      yield mil += 1;
  })();

  return () => id.next().value;
})();
// create unique incrementing id starting from provided value or zero
// good for temporary things or things that id resets
const uniqueIncrementingId = ((lastId = 0) => {
  const id = (function*() {
    let numb = lastId;

    while (true)
      yield numb += 1;
  })()

  return (length = 12) => `${id.next().value}`.padStart(length, '0');
})();
// create unique id from letters and numbers
const uniqueAlphaNumericId = (() => {
  const heyStack = '0123456789abcdefghijklmnopqrstuvwxyz';
  const randomInt = () => Math.floor(Math.random() * Math.floor(heyStack.length))

  return (length = 24) => Array.from({length}, () => heyStack[randomInt()]).join('');
})();
6. 创建一个范围内的数字
Python 里我很喜欢的一个功能是 range 函数，而在 JavaScript 里我经常需要自己写这个功能。下面是一个简单的实现，非常适合 for…of 循环以及需要特定范围内数字的情况。
function range(maxOrStart, end = null, step = null) { 
  if(!end) {
    return Array.from({length: maxOrStart}, (_, i) => i)
  }

  if(end <= maxOrStart) {
    return [];
  }

  if(step !== null) {
    return Array.from(
      {length: Math.ceil(((end - maxOrStart) / step))}, 
      (_, i) => (i * step) + maxOrStart
    );
  }

  return Array.from(
    {length: Math.ceil((end - maxOrStart))}, 
    (_, i) => i + maxOrStart
  );
}
7. 格式化 JSON 字符串，stringify 任何内容
我在使用 NodeJs 将对象记录到控制台时经常使用这种方法。JSON.stringify 方法需要第三个参数，该参数必须有多个空格以缩进行。第二个参数可以为 null，但你可以用它来处理 function、Set、Map、Symbol 之类 JSON.stringify 方法无法处理或完全忽略的内容。
图片
const stringify = (() => {
  const replacer = (key, val) => {
    if(typeof val === 'symbol') {
      return val.toString();
    }
    if(val instanceof Set) {
      return Array.from(val);
    }
    if(val instanceof Map) {
      return Array.from(val.entries());
    }
    if(typeof val === 'function') {
      return val.toString();
    }
    return val;
  }

  return (obj, spaces = 0) => JSON.stringify(obj, replacer, spaces)
})();
8. 顺序执行 promise
如果你有一堆异步或普通函数都返回 promise，要求你一个接一个地执行，这个工具就会很有用。它会获取函数或 promise 列表，并使用数组 reduce 方法按顺序解析它们。
const asyncSequentializer = (() => {
  const toPromise = (x) => {
    if(x instanceof Promise) { // if promise just return it
      return x;
    }

    if(typeof x === 'function') {
      // if function is not async this will turn its result into a promise
      // if it is async this will await for the result
      return (async () => await x())();
    }

    return Promise.resolve(x)
  }

  return (list) => {
    const results = [];

    return list
      .reduce((lastPromise, currentPromise) => {
        return lastPromise.then(res => {
          results.push(res); // collect the results
          return toPromise(currentPromise);
        });
      }, toPromise(list.shift()))
      // collect the final result and return the array of results as resolved promise
      .then(res => Promise.resolve([...results, res]));
  }
})();
9. 轮询数据
如果你需要持续检查数据更新，但系统中没有 WebSocket，则可以使用这个工具来执行操作。它非常适合上传文件时，想要持续检查文件是否已完成处理的情况，或者使用第三方 API（例如 dropbox 或 uber）并且想要持续检查过程是否完成或骑手是否到达目的地的情况。
async function poll(fn, validate, interval = 2500) {
  const resolver = async (resolve, reject) => {
    try { // catch any error thrown by the "fn" function
      const result = await fn(); // fn does not need to be asynchronous or return promise
      // call validator to see if the data is at the state to stop the polling
      const valid = validate(result);
      if (valid === true) {
        resolve(result);
      } else if (valid === false) {
        setTimeout(resolver, interval, resolve, reject);
      } // if validator returns anything other than "true" or "false" it stops polling
    } catch (e) {
      reject(e);
    }
  };
  return new Promise(resolver);
}
10. 等待所有 promise 完成
这个算不上是代码解决方案，更多是对 Promise API 的强化。这个 API 在不断进化，以前我还为“allSettled”“race”和“any”做了代码实现，现在直接用 API 的就好了。
图片
11. 交换数组值的位置
ES6 开始，从数组中的不同位置交换值变得容易多了。这个做起来不难，但是了解一下也不错，
图片
12. 条件对象键
我最喜欢这条技巧了，我在使用 React 更新状态时经常用它。你可以将条件包装在括号中来有条件地将一个键插入一个 spread 对象。
图片
13. 使用变量作为对象键
当你有一个字符串变量，并想将其用作对象中的键以设置一个值时可以用它。
图片
14. 检查对象里的键
这是一个很好的技巧，可以帮助你检查对象键。
图片
15. 删除数组重复项
数组中经常有重复的值，你可以使用 Set 数据结构来消除它。它适用于许多数据类型，并且 set 有多种检查相等性的方法，很好用。对于不同实例或对象的情况，你还是可以使用 Set 来跟踪特定事物并过滤出重复的对象。
图片
16. 在 ArrayforEach 中执行“break”和“continue”
我真的很喜欢使用数组“.forEach”方法，但有时我需要提早退出或继续进行下一个循环，而不想用 for...loop。你可以复制“continue”语句行为来提前返回，但如果要复制“break”行为，则需要使用数组“.some”方法。
图片
17. 使用别名和默认值来销毁
Destructuring（销毁）是 JavaScript 最好用的功能之一，而且你可以使用“冒号”设置别名，并使用“等号”设置属性默认值。
图片
18. 可选链和空值合并
深入检查对象属性并处理 null 和 undefined 值时，你可以使用几个非常好用的 JavaScript 功能来解决常见的问题。
图片
19. 用函数扩展类
我经常对别人讲，JavaScript 类只是构造函数和底层的原型，不是像 Java 中那样的真实概念。一个证据是，你可以只使用一个构造函数来扩展一个类。在私有内容里这个很好用，在类里“#”这些看着很奇怪，并且用于 babel 或 WebPack 时，编译出来的代码更少。
图片
20. 扩展构造函数
类的一个问题是你只能扩展一个其他类。使用构造函数，你可以使用多个构造函数来构成一个函数，这样就会灵活多了。你可以使用函数原型的.apply 或.call 方法来实现。你甚至可以只扩展函数的一部分，只要它是一个对象即可。
图片
21. 循环任何内容
有时，你需要循环任何可迭代的内容（Set、Map、Object、Array、String 等）。这个非常简单的 forEach 函数工具就可以做到这一点。如果回调返回 true，它将退出循环。
function forEach(list, callback) {
  const entries = Object.entries(list);
  let i = 0;
  const len = entries.length;

  for(;i < len; i++) {
    const res = callback(entries[i][1], entries[i][0], list);

    if(res === true) break;
  }
}
22. 使函数参数为 required
这是一种确保函数调用了完成工作所需内容的绝佳方法。你可以使用默认参数值的特性来调用函数，然后就会抛出一个错误。如果调用该函数时带上了它需要的值，则该值将替换该函数，并且什么也不会发生。使用 undefined 调用也有相同的效果。
function required(argName = 'param') {
  throw new Error(`"${argName}" is required`)
}
function iHaveRequiredOptions(arg1 = required('arg1'), arg2 = 10) {
  console.log(arg1, arg2)
}
iHaveRequiredOptions(); // throws "arg1" is required
iHaveRequiredOptions(12); // prints 12, 10
iHaveRequiredOptions(12, 24); // prints 12, 24
iHaveRequiredOptions(undefined, 24); // throws "arg1" is required
23. 创建模块或单例
很多时候，你需要在加载时初始化某些内容，设置它需要的各种事物，然后就可以在应用程序中到处使用它，而无需再做什么补充工作。你可以使用 IIFE 函数来做到这一点，这个函数太好用了。这种模块模式用来隔离事物非常好用，它可以只暴露需要交互的内容。
图片
24. 深度克隆对象
开发人员通常会安装一些类似“lodash”的库来执行这一操作，但使用纯 JavaScript 来实现确实也很容易。这是一个简单的递归函数：只要是一个对象，就使用函数的构造器将其重新初始化为一个克隆，然后对所有属性重复该过程。
const deepClone = obj => {
  let clone = obj;
  if (obj && typeof obj === "object") {
    clone = new obj.constructor();

    Object.getOwnPropertyNames(obj).forEach(
      prop => (clone[prop] = deepClone(obj[prop]))
    );
  }
  return clone;
};
25. 深度冻结对象
如果你喜欢不变性，那么这个工具你一定要常备。
const deepClone = obj => {
  let clone = obj;
  if (obj && typeof obj === "object") {
    clone = new obj.constructor();

    Object.getOwnPropertyNames(obj).forEach(
      prop => (clone[prop] = deepClone(obj[prop]))
    );
  }
  return clone;
};